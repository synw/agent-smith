let f=[],k=0;const m=4;let A=o=>{let i=[],e={get(){return e.lc||e.listen(()=>{})(),e.value},lc:0,listen(r){return e.lc=i.push(r),()=>{for(let u=k+m;u<f.length;)f[u]===r?f.splice(u,m):u+=m;let a=i.indexOf(r);~a&&(i.splice(a,1),--e.lc||e.off())}},notify(r,a){let u=!f.length;for(let t of i)f.push(t,e.value,r,a);if(u){for(k=0;k<f.length;k+=m)f[k](f[k+1],f[k+2],f[k+3]);f.length=0}},off(){},set(r){let a=e.value;a!==r&&(e.value=r,e.notify(a))},subscribe(r){let a=e.listen(r);return r(e.value),a},value:o};return e},p=(o={})=>{let i=A(o);return i.setKey=function(e,r){let a=i.value;typeof r>"u"&&e in i.value?(i.value={...i.value},delete i.value[e],i.notify(a,e)):i.value[e]!==r&&(i.value={...i.value,[e]:r},i.notify(a,e))},i};const _=o=>{const i=o.id,e=o.title??"",r=o.description??"",a=o.run,u=o.abort,t=p({isRunning:!1,isCompleted:!1,data:null}),T=async(c,y)=>{t.setKey("isRunning",!0),t.setKey("data",null);let h={};return a&&(h=await a(c)),y&&K(!0,h),h},w=async c=>T(c,!0),R=async c=>T(c,!1),K=(c,y)=>{t.setKey("isRunning",!1),t.setKey("isCompleted",c),y&&t.setKey("data",y)};return{id:i,title:e,description:r,state:t,run:w,abort:async(c=null)=>{if(!u){console.warn(`The task ${i} has no abort method`);return}if(!t.get().isRunning)throw new Error("Nothing to abort, no task is running");await u(c),t.setKey("isRunning",!1),t.setKey("isCompleted",!1),t.setKey("data",null)},start:R,finish:K}},x=o=>{const i=o.name;let e={};o.tasks.forEach(n=>{const s=_(n);e[s.id]=s});const r=o.title,a=o.tmem??{},u=o.tmem!==void 0,t=p({isRunning:!1,isCompleted:!1,isRunningTask:!1,runningTask:""}),T=async(n,s,l)=>{try{let g={};return l?(g=await n.run(s),R(n,g,!0)):g=await n.start(s),g}catch(g){throw R(n,{},!1),g}},w=async(n,s,l)=>{t.setKey("isRunningTask",!0),t.setKey("runningTask",n),u&&(l?await a.reRunTask(n):await a.runTask(n,s))},R=async(n,s,l)=>{t.setKey("isRunningTask",!1),t.setKey("runningTask",""),n.finish(l,s),u&&await a.finishTask(n.id,l,s)},K=async(n={})=>{if(!t.get().isRunningTask)throw new Error("No task is running, can not continue");const s=d(t.get().runningTask);return await T(s,n,!1)},E=async(n,s={})=>{if(t.get().isRunningTask)throw new Error("A task is already running");w(n,s,!1);const l=d(n);return await T(l,s,!0)},c=async(n,s={})=>{if(t.get().isRunningTask)throw new Error("A task is already running");await w(n,s,!1)},y=async n=>{if(t.get().isRunningTask)throw new Error("A task is already running");await w(n,{},!0)},h=async(n,s)=>{const l=d(t.get().runningTask);l.finish(n,s),t.setKey("isRunningTask",!1),t.setKey("runningTask",""),u&&await a.finishTask(l.id,n,s)},v=async(n=null)=>{if(!t.get().isRunningTask)throw new Error("No task is running, nothing to abort");const s=d(t.get().runningTask);if(!s)throw new Error("No running task found, can not abort");if(!s.abort)throw new Error(`Running task ${s.id} does not have an abort method`);try{await s.abort(n)}catch(l){throw l}finally{t.setKey("isRunningTask",!1),t.setKey("runningTask",""),u&&await a.finishTask(s.id,!1)}},C=async()=>{t.setKey("isRunning",!0),t.setKey("isCompleted",!1),u&&await a.start(i,Object.values(e))},N=async n=>{t.setKey("isRunning",!1),t.setKey("isCompleted",n),u&&await a.finish()},d=n=>{try{return e[n]}catch{throw new Error(`Task ${n} not found`)}};return{name:i,title:r,state:t,get tasks(){return e},set tasks(n){e=n},tmem:a,runTask:E,continueTask:K,startTask:c,reStartTask:y,finishTask:h,abortTask:v,start:C,finish:N,getTaskById:d,syncMem:async()=>{if(u){await a.init();const n=await a.job.get("isRunning");t.setKey("isRunning",n);const s=await a.job.get("runningTask");s&&d(s);const l=await a.tasks.all();Object.values(e).forEach(g=>{const b=l[g.id];b&&(g.state.setKey("isCompleted",b.isCompleted),g.state.setKey("data",b.data))})}}}};async function $(o){return console.log("Task 1 is running with input data:",o),await new Promise(i=>setTimeout(i,3e3)),console.log("Task 1 is finished"),{data:[0,1,2]}}const I=_({id:"task1",title:"Demo task 1",run:$});export{_ as a,I as t,x as u};
