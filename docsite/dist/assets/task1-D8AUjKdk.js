import{m as b}from"./index-Bda8kKQR.js";const E=i=>{const f=i.id,c=i.title??"",T=i.description??"",a=i.run,o=i.abort,n=b({isRunning:!1,isCompleted:!1,data:null}),k=async(r,l)=>{n.setKey("isRunning",!0);let w={};return a&&(w=await a(r)),l&&(n.setKey("isRunning",!1),n.setKey("isCompleted",!0)),w};return{id:f,title:c,description:T,state:n,run:async r=>k(r,!0),abort:async(r=null)=>{if(!o){console.warn(`The task ${f} has no abort method`);return}if(!n.get().isRunning)throw new Error("Nothing to abort, no task is running");await o(r),n.setKey("isRunning",!1),n.setKey("isCompleted",!1),n.setKey("data",null)},start:async r=>k(r,!1),finish:(r,l)=>{n.setKey("isRunning",!1),n.setKey("isCompleted",r),l&&n.setKey("data",l)}}},N=i=>{const f=i.name,c={};i.tasks.forEach(t=>{const s=E(t);c[s.id]=s});const T=i.title,a=i.tmem??{},o=i.tmem!==void 0,n=b({isRunning:!1,isCompleted:!1,isRunningTask:!1,runningTask:""}),k=async(t,s,e)=>{try{let u={};return e?(u=await t.run(s),d(t,u,!0)):u=await t.start(s),u}catch(u){throw d(t,{},!1),u}},y=async(t,s,e)=>{n.setKey("isRunningTask",!0),n.setKey("runningTask",t),o&&(e?await a.reRunTask(t):await a.runTask(t,s))},d=async(t,s,e)=>{n.setKey("isRunningTask",!1),n.setKey("runningTask",""),t.finish(e,s),o&&await a.finishTask(t.id,e,s)},K=async(t={})=>{if(!n.get().isRunningTask)throw new Error("No task is running, can not continue");const s=g(n.get().runningTask);return await k(s,t,!1)},R=async(t,s={})=>{if(n.get().isRunningTask)throw new Error("A task is already running");y(t,s,!1);const e=g(t);return await k(e,s,!0)},r=async(t,s={})=>{if(n.get().isRunningTask)throw new Error("A task is already running");await y(t,s,!1)},l=async t=>{if(n.get().isRunningTask)throw new Error("A task is already running");await y(t,{},!0)},w=async(t,s)=>{const e=g(n.get().runningTask);e.finish(t,s),n.setKey("isRunningTask",!1),n.setKey("runningTask",""),o&&await a.finishTask(e.id,t,s)},m=async(t=null)=>{if(!n.get().isRunningTask)throw new Error("No task is running, nothing to abort");const s=g(n.get().runningTask);if(!s)throw new Error("No running task found, can not abort");if(!s.abort)throw new Error(`Running task ${s.id} does not have an abort method`);try{await s.abort(t)}catch(e){throw e}finally{n.setKey("isRunningTask",!1),n.setKey("runningTask",""),o&&await a.finishTask(s.id,!1)}},C=async()=>{n.setKey("isRunning",!0),n.setKey("isCompleted",!1),o&&await a.start(f,Object.values(c))},p=async t=>{n.setKey("isRunning",!1),n.setKey("isCompleted",t),o&&await a.finish(),Object.values(c).forEach(s=>{s.state.setKey("data",{}),s.state.setKey("isCompleted",!1)})},g=t=>{try{return c[t]}catch{throw new Error(`Task ${t} not found`)}};return{name:f,title:T,state:n,tasks:c,tmem:a,runTask:R,continueTask:K,startTask:r,reStartTask:l,finishTask:w,abortTask:m,start:C,finish:p,getTaskById:g,syncMem:async()=>{if(o){await a.init();const t=await a.job.get("isRunning");n.setKey("isRunning",t);const s=await a.job.get("runningTask");s&&g(s);const e=await a.tasks.all();Object.values(c).forEach(u=>{const h=e[u.id];h&&(u.state.setKey("isCompleted",h.isCompleted),u.state.setKey("data",h.data))})}}}};async function _(i){return console.log("Task 1 is running with input data:",i),await new Promise(f=>setTimeout(f,3e3)),console.log("Task 1 is finished"),{data:[0,1,2]}}const v=E({id:"task1",title:"Demo task 1",run:_});export{E as a,v as t,N as u};
