import{C as b}from"./index-oQ1hFXLf.js";const E=i=>{const f=i.id,c=i.title??"",h=i.description??"",a=i.run,o=i.abort,t=b({isRunning:!1,isCompleted:!1,data:null}),k=async(r,l)=>{t.setKey("isRunning",!0),t.setKey("data",null);let w={};return a&&(w=await a(r)),l&&d(!0,w),w},y=async r=>k(r,!0),T=async r=>k(r,!1),d=(r,l)=>{t.setKey("isRunning",!1),t.setKey("isCompleted",r),l&&t.setKey("data",l)};return{id:f,title:c,description:h,state:t,run:y,abort:async(r=null)=>{if(!o){console.warn(`The task ${f} has no abort method`);return}if(!t.get().isRunning)throw new Error("Nothing to abort, no task is running");await o(r),t.setKey("isRunning",!1),t.setKey("isCompleted",!1),t.setKey("data",null)},start:T,finish:d}},j=i=>{const f=i.name;let c={};i.tasks.forEach(n=>{const s=E(n);c[s.id]=s});const h=i.title,a=i.tmem??{},o=i.tmem!==void 0,t=b({isRunning:!1,isCompleted:!1,isRunningTask:!1,runningTask:""}),k=async(n,s,e)=>{try{let u={};return e?(u=await n.run(s),T(n,u,!0)):u=await n.start(s),u}catch(u){throw T(n,{},!1),u}},y=async(n,s,e)=>{t.setKey("isRunningTask",!0),t.setKey("runningTask",n),o&&(e?await a.reRunTask(n):await a.runTask(n,s))},T=async(n,s,e)=>{t.setKey("isRunningTask",!1),t.setKey("runningTask",""),n.finish(e,s),o&&await a.finishTask(n.id,e,s)},d=async(n={})=>{if(!t.get().isRunningTask)throw new Error("No task is running, can not continue");const s=g(t.get().runningTask);return await k(s,n,!1)},R=async(n,s={})=>{if(t.get().isRunningTask)throw new Error("A task is already running");y(n,s,!1);const e=g(n);return await k(e,s,!0)},r=async(n,s={})=>{if(t.get().isRunningTask)throw new Error("A task is already running");await y(n,s,!1)},l=async n=>{if(t.get().isRunningTask)throw new Error("A task is already running");await y(n,{},!0)},w=async(n,s)=>{const e=g(t.get().runningTask);e.finish(n,s),t.setKey("isRunningTask",!1),t.setKey("runningTask",""),o&&await a.finishTask(e.id,n,s)},m=async(n=null)=>{if(!t.get().isRunningTask)throw new Error("No task is running, nothing to abort");const s=g(t.get().runningTask);if(!s)throw new Error("No running task found, can not abort");if(!s.abort)throw new Error(`Running task ${s.id} does not have an abort method`);try{await s.abort(n)}catch(e){throw e}finally{t.setKey("isRunningTask",!1),t.setKey("runningTask",""),o&&await a.finishTask(s.id,!1)}},C=async()=>{t.setKey("isRunning",!0),t.setKey("isCompleted",!1),o&&await a.start(f,Object.values(c))},_=async n=>{t.setKey("isRunning",!1),t.setKey("isCompleted",n),o&&await a.finish()},g=n=>{try{return c[n]}catch{throw new Error(`Task ${n} not found`)}};return{name:f,title:h,state:t,get tasks(){return c},set tasks(n){c=n},tmem:a,runTask:R,continueTask:d,startTask:r,reStartTask:l,finishTask:w,abortTask:m,start:C,finish:_,getTaskById:g,syncMem:async()=>{if(o){await a.init();const n=await a.job.get("isRunning");t.setKey("isRunning",n);const s=await a.job.get("runningTask");s&&g(s);const e=await a.tasks.all();Object.values(c).forEach(u=>{const K=e[u.id];K&&(u.state.setKey("isCompleted",K.isCompleted),u.state.setKey("data",K.data))})}}}};async function p(i){return console.log("Task 1 is running with input data:",i),await new Promise(f=>setTimeout(f,3e3)),console.log("Task 1 is finished"),{data:[0,1,2]}}const v=E({id:"task1",title:"Demo task 1",run:p});export{E as a,v as t,j as u};
