let g=[],_=(l,a)=>{let o=[],u={get(){return u.lc||u.listen(()=>{})(),u.value},l:a||0,lc:0,listen(e,f){return u.lc=o.push(e,f||u.l)/2,()=>{let s=o.indexOf(e);~s&&(o.splice(s,2),--u.lc||u.off())}},notify(e,f){let s=!g.length;for(let i=0;i<o.length;i+=2)g.push(o[i],o[i+1],u.value,e,f);if(s){for(let i=0;i<g.length;i+=5){let c;for(let T=i+1;!c&&(T+=5)<g.length;)g[T]<g[i+1]&&(c=g.push(g[i],g[i+1],g[i+2],g[i+3],g[i+4]));c||g[i](g[i+2],g[i+3],g[i+4])}g.length=0}},off(){},set(e){let f=u.value;f!==e&&(u.value=e,u.notify(f))},subscribe(e,f){let s=u.listen(e,f);return e(u.value),s},value:l};return u},p=(l={})=>{let a=_(l);return a.setKey=function(o,u){let e=a.value;typeof u>"u"&&o in a.value?(a.value={...a.value},delete a.value[o],a.notify(e,o)):a.value[o]!==u&&(a.value={...a.value,[o]:u},a.notify(e,o))},a};const C=l=>{const a=l.id,o=l.title??"",u=l.description??"",e=l.type??"",f=(l==null?void 0:l.properties)??{},s=l.run,i=l.abort,c=p({isRunning:!1,isCompleted:!1,data:null}),T=async(k,y,v)=>{c.setKey("isRunning",!0),c.setKey("data",null);let K;if(s)try{return K=await s(k,y),v&&R(!0,K),K}catch(w){throw new Error(`${a}: ${w}`)}else throw new Error(`${a}: no run function is defined for the task`)},b=async(k,y={})=>T(k,y,!0),m=async(k,y={})=>T(k,y,!1),R=(k,y)=>{c.setKey("isRunning",!1),c.setKey("isCompleted",k),y&&c.setKey("data",y)};return{id:a,title:o,description:u,properties:f,type:e,state:c,run:b,abort:async(k=null)=>{if(!i){console.warn(`The task ${a} has no abort method`);return}if(!c.get().isRunning)throw new Error("Nothing to abort, no task is running");await i(k),c.setKey("isRunning",!1),c.setKey("isCompleted",!1),c.setKey("data",null)},start:m,finish:R}},A=l=>{const a=l.name;let o={};l.tasks.forEach(t=>{const n=C(t);o[n.id]=n});const u=l.title,e=l.tmem??{},f=l.tmem!==void 0,s=p({isRunning:!1,isCompleted:!1,isRunningTask:!1,runningTask:""}),i=async(t,n,r,d)=>{try{let h;return d?(h=await t.run(n,r),T(t,h,!0)):h=await t.start(n,r),h}catch(h){throw T(t,{},!1),h}},c=async(t,n={},r,d)=>{s.setKey("isRunningTask",!0),s.setKey("runningTask",t),f&&(d?await e.reRunTask(t,n,r):await e.runTask(t,n,r))},T=async(t,n,r)=>{s.setKey("isRunningTask",!1),s.setKey("runningTask",""),t.finish(r,n),f&&await e.finishTask(t.id,r,n)},b=async(t={},n={})=>{if(!s.get().isRunningTask)throw new Error("No task is running, can not continue");const r=w(s.get().runningTask);return await i(r,t,n,!1)},m=async(t,n={},r={})=>{if(s.get().isRunningTask)throw new Error("A task is already running");await c(t,n,r,!1);const d=w(t);return await i(d,n,r,!0)},R=async(t,n={},r={})=>{if(s.get().isRunningTask)throw new Error("A task is already running");await c(t,n,r,!1)},E=async(t,n={},r={})=>{if(s.get().isRunningTask)throw new Error("A task is already running");await c(t,n,r,!0)},k=async(t,n)=>{const r=w(s.get().runningTask);r.finish(t,n),s.setKey("isRunningTask",!1),s.setKey("runningTask",""),f&&await e.finishTask(r.id,t,n)},y=async(t=null)=>{if(!s.get().isRunningTask)throw new Error("No task is running, nothing to abort");const n=w(s.get().runningTask);if(!n)throw new Error("No running task found, can not abort");if(!n.abort)throw new Error(`Running task ${n.id} does not have an abort method`);try{await n.abort(t)}catch(r){throw r}finally{s.setKey("isRunningTask",!1),s.setKey("runningTask",""),f&&await e.finishTask(n.id,!1)}},v=async()=>{s.setKey("isRunning",!0),s.setKey("isCompleted",!1),f&&await e.start(a,Object.values(o))},K=async t=>{s.setKey("isRunning",!1),s.setKey("isCompleted",t),f&&await e.finish()},w=t=>{try{return o[t]}catch{throw new Error(`Task ${t} not found`)}};return{name:a,title:u,state:s,get tasks(){return o},set tasks(t){o=t},tmem:e,runTask:m,continueTask:b,startTask:R,reStartTask:E,finishTask:k,abortTask:y,start:v,finish:K,getTaskById:w,syncMem:async()=>{if(f){await e.init();const t=await e.job.get("isRunning");s.setKey("isRunning",t);const n=await e.job.get("runningTask");n&&w(n);const r=await e.tasks.all();Object.values(o).forEach(d=>{const h=r[d.id];h&&(d.state.setKey("isCompleted",h.isCompleted),d.state.setKey("data",h.data))})}}}};async function $(l){return console.log("Task 1 is running with input data:",l),await new Promise(a=>setTimeout(a,3e3)),console.log("Task 1 is finished"),{data:[0,1,2]}}const N=C({id:"task1",title:"Demo task 1",run:$});export{C as a,N as t,A as u};
