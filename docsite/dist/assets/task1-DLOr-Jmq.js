let g=[],T=0;const m=4;let A=u=>{let i=[],s={get(){return s.lc||s.listen(()=>{})(),s.value},lc:0,listen(o){return s.lc=i.push(o),()=>{for(let l=T+m;l<g.length;)g[l]===o?g.splice(l,m):l+=m;let e=i.indexOf(o);~e&&(i.splice(e,1),--s.lc||s.off())}},notify(o,e){let l=!g.length;for(let a of i)g.push(a,s.value,o,e);if(l){for(T=0;T<g.length;T+=m)g[T](g[T+1],g[T+2],g[T+3]);g.length=0}},off(){},set(o){let e=s.value;e!==o&&(s.value=o,s.notify(e))},subscribe(o){let e=s.listen(o);return o(s.value),e},value:u};return s},C=(u={})=>{let i=A(u);return i.setKey=function(s,o){let e=i.value;typeof o>"u"&&s in i.value?(i.value={...i.value},delete i.value[s],i.notify(e,s)):i.value[s]!==o&&(i.value={...i.value,[s]:o},i.notify(e,s))},i};const N=u=>{const i=u.id,s=u.title??"",o=u.description??"",e=u.type??"",l=u.run,a=u.abort,c=C({isRunning:!1,isCompleted:!1,data:null}),w=async(f,k,v)=>{c.setKey("isRunning",!0),c.setKey("data",null);let R={};return l&&(R=await l(f,k)),v&&b(!0,R),R},K=async(f,k={})=>w(f,k,!0),E=async(f,k={})=>w(f,k,!1),b=(f,k)=>{c.setKey("isRunning",!1),c.setKey("isCompleted",f),k&&c.setKey("data",k)};return{id:i,title:s,description:o,type:e,state:c,run:K,abort:async(f=null)=>{if(!a){console.warn(`The task ${i} has no abort method`);return}if(!c.get().isRunning)throw new Error("Nothing to abort, no task is running");await a(f),c.setKey("isRunning",!1),c.setKey("isCompleted",!1),c.setKey("data",null)},start:E,finish:b}},x=u=>{const i=u.name;let s={};u.tasks.forEach(n=>{const t=N(n);s[t.id]=t});const o=u.title,e=u.tmem??{},l=u.tmem!==void 0,a=C({isRunning:!1,isCompleted:!1,isRunningTask:!1,runningTask:""}),c=async(n,t,r,d)=>{try{let y={};return d?(y=await n.run(t,r),K(n,y,!0)):y=await n.start(t,r),y}catch(y){throw K(n,{},!1),y}},w=async(n,t={},r,d)=>{a.setKey("isRunningTask",!0),a.setKey("runningTask",n),l&&(d?await e.reRunTask(n,t,r):await e.runTask(n,t,r))},K=async(n,t,r)=>{a.setKey("isRunningTask",!1),a.setKey("runningTask",""),n.finish(r,t),l&&await e.finishTask(n.id,r,t)},E=async(n={},t={})=>{if(!a.get().isRunningTask)throw new Error("No task is running, can not continue");const r=h(a.get().runningTask);return await c(r,n,t,!1)},b=async(n,t={},r={})=>{if(a.get().isRunningTask)throw new Error("A task is already running");w(n,t,r,!1);const d=h(n);return await c(d,t,r,!0)},p=async(n,t={},r={})=>{if(a.get().isRunningTask)throw new Error("A task is already running");await w(n,t,r,!1)},f=async(n,t={},r={})=>{if(a.get().isRunningTask)throw new Error("A task is already running");await w(n,t,r,!0)},k=async(n,t)=>{const r=h(a.get().runningTask);r.finish(n,t),a.setKey("isRunningTask",!1),a.setKey("runningTask",""),l&&await e.finishTask(r.id,n,t)},v=async(n=null)=>{if(!a.get().isRunningTask)throw new Error("No task is running, nothing to abort");const t=h(a.get().runningTask);if(!t)throw new Error("No running task found, can not abort");if(!t.abort)throw new Error(`Running task ${t.id} does not have an abort method`);try{await t.abort(n)}catch(r){throw r}finally{a.setKey("isRunningTask",!1),a.setKey("runningTask",""),l&&await e.finishTask(t.id,!1)}},R=async()=>{a.setKey("isRunning",!0),a.setKey("isCompleted",!1),l&&await e.start(i,Object.values(s))},_=async n=>{a.setKey("isRunning",!1),a.setKey("isCompleted",n),l&&await e.finish()},h=n=>{try{return s[n]}catch{throw new Error(`Task ${n} not found`)}};return{name:i,title:o,state:a,get tasks(){return s},set tasks(n){s=n},tmem:e,runTask:b,continueTask:E,startTask:p,reStartTask:f,finishTask:k,abortTask:v,start:R,finish:_,getTaskById:h,syncMem:async()=>{if(l){await e.init();const n=await e.job.get("isRunning");a.setKey("isRunning",n);const t=await e.job.get("runningTask");t&&h(t);const r=await e.tasks.all();Object.values(s).forEach(d=>{const y=r[d.id];y&&(d.state.setKey("isCompleted",y.isCompleted),d.state.setKey("data",y.data))})}}}};async function $(u){return console.log("Task 1 is running with input data:",u),await new Promise(i=>setTimeout(i,3e3)),console.log("Task 1 is finished"),{data:[0,1,2]}}const I=N({id:"task1",title:"Demo task 1",run:$});export{N as a,I as t,x as u};
