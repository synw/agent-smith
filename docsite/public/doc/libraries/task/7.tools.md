# Tools

A tasks uses an agent that has the hability to use tools.

## Define tools

Create a function for a tool execution:

```js
function get_current_weather(args) {
    console.log("Running the get_current_weather tool with args", args);
    return { "temp": 20.5, "weather": "rain" }
}
```

Create a tool definition:

```js
const weatherToolDef = {
    "name": "get_current_weather",
    "description": "Get the current weather",
    "arguments": {
        "location": {
            "description": "The city and state, e.g. San Francisco, CA"
        }
    },
    "execute": get_current_weather,
};
```

Create a basic task:

```js
const ymlTaskDef = `name: tools_use_example
description: Tools use example
prompt: |-
    {prompt}
template:
    afterSystem: |-
        
        You are an AI touristic assistant
model:
    name: "qwen/qwen3-30b-a3b:free"
```

## Configure with tools

Initialize the task from "@agent-smith/task";zwith an agent connected to an Openrouter backend:

```js
import { Agent } from "@agent-smith/agent";
import { TaskDef} from "@agent-smith/task";

const lm = new Lm({
    providerType: "openai",
    serverUrl: "https://openrouter.ai/api/v1",
    apiKey: process.env.OPENROUTER_API_KEY,
    onToken: (t) => process.stdout.write(t),
});
const agent = new Agent(lm);
const task = new Task(agent, ymlTaskDef);
```

Add the tools:

```js
task.addTools([weatherToolDef]);
```

Run the task:

```js
const _prompt = `I am landing in Barcelona soon: I plan to reach my hotel 
and then go for outdoor sport. How are the conditions in the city?`;
const answer = await task.run(
    { prompt: _prompt }, 
    // specify here for a different model than the one declared in the task
    //{ model: "qwen/qwen3-235b-a22b:free" }
);
console.log("\n\n----------- Template history:");
console.log(answer.template.history);
```

The model will be able to call the weather tool by it's own.

## Supervised tool call

It is possible to define an authorization function to check if the model can call a tool. Example: ask
the user before calling a tool: create a `canExecuteTool` function

```ts
import { createInterface } from 'readline/promises';
import { stdin as input, stdout as output } from 'process';
import type { ToolSpec } from "@locallm/types";

const rl = createInterface({
    input,
    output
});

async function askUser(question: string) {
    const answer = await rl.question(question);
    return answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes';
}

async function canExecuteTool(tool: ToolSpec): Promise<boolean> {
    const argsNames = Object.keys(tool.arguments);
    const msg = `Execute tool ${tool.name} with arguments ${argsNames.join(", ")}`;
    return await askUser(msg + ' (y/n): ');
}
```

Now declare the authorization function in the tool definition:

```js
const weatherToolDef = {
    "name": "get_current_weather",
    "description": "Get the current weather",
    "arguments": {
        "location": {
            "description": "The city and state, e.g. San Francisco, CA"
        }
    },
    "execute": get_current_weather,
    "canRun": canExecuteTool,
};
```

When the model wants to call this tool it has to be authorized by the user.

<a href="javascript:openLink('/libraries/task/fragments')">Next: fragments</a>